# -*- coding: utf-8 -*-
"""Heart disease.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z16Ep5M6UTFvSJq_Us9QCVstsBEQwVtQ
"""

import pandas as pd
import seaborn as sns
import numpy as np
from google.colab import drive

# Mount Google Drive7

drive.mount('/content/drive')

import pandas as pd
# Heart disease Loading Data
df = "/content/drive/MyDrive/heart_data.csv"

df = pd.read_csv('/content/drive/MyDrive/heart_data.csv')
print(df.head())

# Show tail of each dataset
print("Tail of df:")
print(df.tail())

# Display the entire contents of each dataset
print("df:")
print(df)

df = df.drop("Unnamed: 0", axis=1)
#A few plots in Seaborn to understand the data

sns.lmplot(x='biking', y='heart.disease', data=df)
sns.lmplot(x='smoking', y='heart.disease', data=df)

import matplotlib.pyplot as plt
# Heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(df[['biking', 'smoking', 'heart.disease']].corr(), annot=True, cmap='coolwarm')
plt.title('Correlation Heatmap')
plt.show()

x_df = df.drop('heart.disease', axis=1)
y_df = df['heart.disease']

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(x_df, y_df, test_size=0.3, random_state=42)

from sklearn import linear_model

#Create Linear Regression object
model = linear_model.LinearRegression()

"""I will call the fit method to train the model using independent variables.
And check the value that needs to be predicted (Images_Analyzed)

"""

model.fit(X_train, y_train) #Indep variables, dep. variable to be predicted
print(model.score(X_train, y_train))  #Prints the R^2 value, a measure of how well

"""#Scatter plot where the x-axis represents the true values and the y-axis represents the predicted values."""

import matplotlib.pyplot as plt
import numpy as np

# Getting predictions
y_pred = model.predict(X_train)

# Plotting
plt.figure(figsize=(8, 6))
plt.scatter(y_train, y_pred, alpha=0.5)
plt.plot([min(y_train), max(y_train)], [min(y_train), max(y_train)], color='red', linestyle='--')
plt.xlabel('True Values')
plt.ylabel('Predicted Values')
plt.title('True vs Predicted Values (Training Set)')
plt.show()

"""#Bar plot to compare the true and predicted values visually"""

# Getting predictions
y_pred = model.predict(X_train)

# Calculate residuals (errors)
residuals = y_train - y_pred

# Plotting a bar plot to compare true and predicted values
plt.figure(figsize=(8, 6))
barWidth = 0.35
true_bars = np.arange(len(y_train))
predicted_bars = [x + barWidth for x in true_bars]
plt.bar(true_bars, y_train, color='b', width=barWidth, edgecolor='blue', label='True Values')
plt.bar(predicted_bars, y_pred, color='r', width=barWidth, edgecolor='red', label='Predicted Values')
plt.xlabel('True Values')
plt.ylabel('Predicted Values')
plt.title('Comparison of True and Predicted Values (Training Set)')
plt.legend()
plt.show()

prediction_test = model.predict(X_test)
print(y_test, prediction_test)
print("Mean sq. errror between y_test and predicted =", np.mean(prediction_test-y_test)**2)

"""#To visualize the relationship between the predicted values and the true values in the test set, as well as the errors, using a heatmap."""

# Getting predictions for the test set
prediction_test = model.predict(X_test)

# Mean squared error
mse = np.mean((prediction_test - y_test) ** 2)
print("Mean squared error between y_test and predicted =", mse)

# Plotting heatmap
plt.figure(figsize=(10, 26))
sns.heatmap(np.array([y_test, prediction_test]).T, cmap='YlGnBu', annot=True, fmt=".2f", cbar_kws={'label': 'Values'})
plt.xlabel('Actual Values and Predicted Values')
plt.ylabel('Data Points')
plt.title('Heatmap of Actual vs Predicted Values (Test Set)')
plt.xticks(ticks=[0.5, 1.5], labels=['Actual', 'Predicted'])
plt.show()

import pickle
pickle.dump(model, open('model.pkl','wb'))

model = pickle.load(open('model.pkl','rb'))
print(model.predict([[20.1, 56.3]]))

#All set to predict the number of images someone would analyze at a given time
#print(model.predict([[13, 2, 23]]))